{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Modélisation des dynamiques économiques et géographique par automates cellulaires "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "On commence par paramétrer la carte qui nous servira à visualiser la simulation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pygame 2.5.2 (SDL 2.28.3, Python 3.12.1)\n",
      "Hello from the pygame community. https://www.pygame.org/contribute.html\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import pygame\n",
    "import random\n",
    "\n",
    "import os\n",
    "  # Use dummy video driver to run Pygame in a notebook\n",
    "import pygame\n",
    "\n",
    "\n",
    "mapsize = 100\n",
    "\n",
    "A_ALIM = 1 #Impact des commerces visités recemment\n",
    "B_ALIM = 1 #Impact de la position maison\n",
    "C_ALIM = 0 #Impact de la position du travail\n",
    "\n",
    "A_DIV = 1\n",
    "B_DIV = 1\n",
    "C_DIV = 1\n",
    "\n",
    "A_MAIS = 1\n",
    "B_MAIS = 1\n",
    "C_MAIS = 1\n",
    "\n",
    "ALPHA_ALIM = 5 #Impact du nombre de voisin\n",
    "BETA_ALIM = 3 #Impact de la distance ci dessus\n",
    "ALPHA_DIV = 2 \n",
    "BETA_DIV = 10\n",
    "GAMMA_DIV = 0.00 #Cout des voisins sur les commerces \n",
    "GAMMA_ALIM = 0.00\n",
    "\n",
    "ALPHA_MAIS = 5 #Impact du nombre de voisin\n",
    "BETA_MAIS = 3 \n",
    "GAMMA_MAIS = 0.00\n",
    "\n",
    "#800 -> 800 00\n",
    "\n",
    "#1 bloc \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "BASE_REV_CONS_PAV = 1000\n",
    "\n",
    "BASE_REV_CONS = 30 *BASE_REV_CONS_PAV #Revenu miniaml\n",
    "BASE_REV_CONS_VILLE = (BASE_REV_CONS_PAV+BASE_REV_CONS_PAV)/2\n",
    "BASE_CONS_ALIM = 300 #Dépense minimal alimentaire\n",
    "\n",
    "BASE_DEP_ALIM_CON_BANL = 100 * BASE_CONS_ALIM \n",
    "BASE_DEP_ALIM_CON_VILLE = 3*BASE_CONS_ALIM \n",
    "BASE_DEP_ALIM_CON_PAV = BASE_CONS_ALIM \n",
    "\n",
    "BASE_COEFF_ALIM_CON_VILLE = 0.2\n",
    "BASE_COEFF_ALIM_CON_BANL = 0.1\n",
    "BASE_COEFF_ALIM_CON_PAV = 0.4\n",
    "\n",
    "BASE_CHARGE_ALIM = 100000\n",
    "BASE_CHARGE_DIV = 100000\n",
    "BASE_CHARGE_MAIS = 10000\n",
    "\n",
    "\n",
    "COM_PROXIMITY = 7\n",
    "BASE_REV_CONS_VILLE = 2*BASE_REV_CONS\n",
    "\n",
    "VERBOSE = 1\n",
    "PROPAGATION_RANGE = 4#must be even"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Map:\n",
    "    \n",
    "    \n",
    "    def __init__(self, size):\n",
    "        self.size = size\n",
    "        self.data = [[[255,255,255] for i in range(size)] for j in range(size)]\n",
    "        self.cons = []\n",
    "        self.comm = []\n",
    "        self.takenMat = [[0 for i in range(size)] for j in range(size)]\n",
    "        self.iter = 0\n",
    "        self.objdata = [[None for i in range(size)]for j in range(size)]\n",
    "        self.free_list = []\n",
    "        self.constructFreeIndex()\n",
    "    def constructFreeIndex(self):\n",
    "        self.free_list = []\n",
    "        for i in range(self.size):\n",
    "            for j in range(self.size):\n",
    "                if(self.takenMat[i][j] == 0):\n",
    "                    self.free_list.append((i,j))\n",
    "    \n",
    "    def updateCase(self,position, color):\n",
    "        if(position.x < self.size and position.y < self.size):\n",
    "            self.data[position.x][position.y] = color\n",
    "    def printMap(self):\n",
    "        # Set grid dimensions based on array size\n",
    "        array = self.data\n",
    "        grid_width = self.size\n",
    "        grid_height = self.size\n",
    "        cell_size = 10\n",
    "        pygame.init()\n",
    "        screen = pygame.display.set_mode((grid_width * cell_size, grid_height * cell_size))\n",
    "        pygame.display.set_caption(\"Array Grid\")\n",
    "        white = (255, 255, 255)\n",
    "        black = (0, 0, 0)\n",
    "        green = (0, 255, 0)\n",
    "        red = (255,0,0)\n",
    "        blue = (0,0,255)\n",
    "        running = True\n",
    "        pause = False\n",
    "        niter = 0\n",
    "        while niter < NUMBER_OF_ITERATIONS:\n",
    "            for event in pygame.event.get():\n",
    "                if event.type == pygame.QUIT:\n",
    "                    running = False\n",
    "                elif event.type == pygame.KEYDOWN:\n",
    "                    if event.key == pygame.K_SPACE:\n",
    "                        if pause:\n",
    "                            pause = False\n",
    "                        else:\n",
    "                            pause = True \n",
    "                    if event.key == pygame.K_p and pause:\n",
    "                        self.printFullSummary()\n",
    "\n",
    "            screen.fill(white)\n",
    "            if(not pause):\n",
    "\n",
    "                for y in range(grid_height):\n",
    "                    for x in range(grid_width):\n",
    "                            pygame.draw.rect(screen, pygame.Color(array[x][y]), (x * cell_size, y * cell_size, cell_size, cell_size))\n",
    "                        \n",
    "                 \n",
    "                map.step()\n",
    "                pygame.display.flip()\n",
    "                niter +=1\n",
    "        pygame.quit()\n",
    "\n",
    "    def updateMap(self, object):\n",
    "        \n",
    "        self.data[x][y] = 1\n",
    "    def print_step_summary(self):\n",
    "        print(\"Step {iter} summary : \\n \".format(iter= self.iter))\n",
    "        for com_t_entities in Commerce.entities:\n",
    "            for com in com_t_entities:\n",
    "                com.printSummary()\n",
    "    def printFullSummary(self):\n",
    "        maxcom = 0\n",
    "        maxcoma = None \n",
    "        for com_t_entities in Commerce.entities:\n",
    "            for com in com_t_entities:\n",
    "                if(com.compte > maxcom):\n",
    "                    maxcom = com.compte \n",
    "                    maxcoma = com \n",
    "        print(\"Most valued commerce at step:{x}\".format(x=self.iter))\n",
    "        maxcoma.printSummary()\n",
    "    def tell(self,newObj):\n",
    "        \n",
    "        x = newObj.position.x\n",
    "        y= newObj.position.y\n",
    "        if 0<x < self.size and 0<y<self.size and self.takenMat[x][y] == 0:\n",
    "            \n",
    "            self.objdata[x][y] = newObj \n",
    "            data = self.data[x][y]\n",
    "            data[0] = 255\n",
    "            data[1] = 255\n",
    "            data[2] = 255\n",
    "            self.takenMat[x][y] = 1\n",
    "            self.free_list.remove((x,y))\n",
    "            for i in range(3):\n",
    "                data[i]= max(data[i]- newObj.color[i], 0)\n",
    "        else:\n",
    "            \n",
    "            print(\"Tried to put outside of map or in used place\")\n",
    "            \n",
    "    def remove(self, oldObj):\n",
    "        x = oldObj.position.x\n",
    "        y =oldObj.position.y\n",
    "        if(x< self.size and y<self.size):\n",
    "            self.objdata[x][y] = None \n",
    "            self.takenMat[x][y] = 0\n",
    "            self.free_list.append((x,y))\n",
    "            data = self.data[x][y]\n",
    "            data[0] = 255\n",
    "            data[1] = 255\n",
    "            data[2] = 255\n",
    "    def step(self):\n",
    "        self.iter+=1\n",
    "        for conso_t_entities in Consommateur.entities:\n",
    "            for conso in conso_t_entities:\n",
    "                conso.consomme()\n",
    "                conso.give()\n",
    "        for com_t_entities in Commerce.entities:\n",
    "            for com in com_t_entities:\n",
    "                com.update()\n",
    "                com.propagateOnMap()\n",
    "        \n",
    "        if(self.iter <=200):\n",
    "            for i in range(1):\n",
    "                CommerceMaison.addNewToMap()\n",
    "                CommerceAlim.addNewToMap()\n",
    "                CommerceDiv.addNewToMap()\n",
    "        \n",
    "        for cons_t_entities in Consommateur.entities:\n",
    "            for cons in cons_t_entities:\n",
    "                cons.resetPos()\n",
    "        \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h1> Consommateurs </h1>\n",
    "On peut ensuite définir des types de consomateurs ; ici, on choisit de considérer trois types de consommateurs : \n",
    "\n",
    "<li>Le consommateur de centre ville</li><li>Le consommateur de banlieue</li> <li>Le consommateur de pavillon</li> \n",
    "\n",
    "Les consommateurs se différencient par leurs revenus, par leur lieu d'habitation ainsi que par la nature de leurs achats. Ainsi, un consommateur de centre ville ne consommera pas ou peu dans les magasins liés à la maison par exemple. \n",
    "\n",
    "Les consommateurs dans ce modèle consomment tous selon une même fonction de consommation, mais qui dépend de leurs revenus et permet donc à chaque classe de consommateur d'avoir un impact différent. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Utils:\n",
    "    class Position:\n",
    "        def __init__(self,x,y):\n",
    "            self.x = x \n",
    "            self.y = y \n",
    "    @classmethod \n",
    "    def distance(cls, pos1, pos2):\n",
    "        return max(abs(pos1.x - pos2.x),abs(pos2.y-pos1.y))\n",
    "    \n",
    "class Consommateur:# =? logement \n",
    "    entities = []\n",
    "    attachedMap = None\n",
    "    def __init__(self, position_x=0, position_y=0, compte = 0, revenu = BASE_REV_CONS, map = None):\n",
    "        print(\"Should not be here\")\n",
    "        pass\n",
    "    \n",
    "\n",
    "    def consomme(self):\n",
    "        coeffs_ = []\n",
    "        \n",
    "        #Choisis si l'on consomme en fonction de dwork, dpos, dw\n",
    "        l = [CommerceAlim.a,CommerceAlim.b, CommerceAlim.c]\n",
    "        index_tire = random.choices(range(len(l)), weights=l)[0]\n",
    "        for commerceAlim in CommerceAlim.entities:\n",
    "            if(commerceAlim.open):\n",
    "                coeffs_.append(commerceAlim.f_attrac(self,index_tire))\n",
    "\n",
    "        if(len(coeffs_)>0):\n",
    "            try:\n",
    "                index_tire = random.choices(range(len(coeffs_)), weights=coeffs_)[0]\n",
    "                self.consomeTo(CommerceAlim.entities[index_tire], self.depenseAlim + self.coeffAlim * self.compte)\n",
    "            except:\n",
    "                pass\n",
    "\n",
    "        #Choisis si on consomme dans un CommerceMaison\n",
    "            \n",
    "        \n",
    "        if(isinstance(self,ConsommateurPavillionnaire)):\n",
    "            if True:\n",
    "                coeffs_ = []\n",
    "                \n",
    "                l = [CommerceMaison.a,CommerceMaison.b, CommerceMaison.c]\n",
    "                index_tire = random.choices(range(len(l)), weights=l)[0]\n",
    "                for commerceAlim in CommerceMaison.entities:\n",
    "                    if(commerceAlim.open):\n",
    "                        coeffs_.append(commerceAlim.f_attrac(self,index_tire))\n",
    "\n",
    "                if(len(coeffs_)>0):\n",
    "                    try:\n",
    "                        index_tire = random.choices(range(len(coeffs_)), weights=coeffs_)[0]\n",
    "                        self.consomeTo(CommerceMaison.entities[index_tire], 0.4*self.compte)\n",
    "                        \n",
    "                    except:\n",
    "                        pass\n",
    "\n",
    "\n",
    "\n",
    "        coeffs_ = []\n",
    "        l = [CommerceDiv.a,CommerceDiv.b, CommerceDiv.c]\n",
    "        index_tire = random.choices(range(len(l)), weights=l)[0]\n",
    "        for commerceDiv in CommerceDiv.entities:\n",
    "            if(commerceDiv.open):\n",
    "                coeffs_.append(commerceDiv.f_attrac(self,index_tire))\n",
    "                \n",
    "        if(len(coeffs_)>0):\n",
    "            for _ in range(4):\n",
    "                try:\n",
    "                    index_tire = random.choices(range(len(coeffs_)), weights=coeffs_)[0]\n",
    "                    self.consomeTo(CommerceDiv.entities[index_tire], int(self.compte/4))\n",
    "                except:\n",
    "                    break\n",
    "    def resetPos(self):\n",
    "        self.positionCom = self.position       \n",
    "    @classmethod\n",
    "    def attachMap(cls, map):\n",
    "        cls.attachedMap = map\n",
    "    def consomeTo(self, commerce,value):\n",
    "        \n",
    "        commerce.turnMoney += min(value, self.compte)\n",
    "        self.compte -= min(value, self.compte)\n",
    "        \n",
    "        self.positionCom = commerce.position \n",
    "\n",
    "    def give(self):\n",
    "        print(str(self)+\" a recu \"+\"+\"+str(self.revenu)+\"\\n\")\n",
    "        print(\"Compte avant : \"+str(self.compte)+ \" Compte après: \" + str(self.compte+self.compte+self.revenu))\n",
    "        self.compte += self.revenu\n",
    "    def __repr__(self):\n",
    "        return \"Conso(\"+str(self.position.x)+\",\"+str(self.position.y)+\")\"  \n",
    "class ConsommateurPavillionnaire(Consommateur):\n",
    "    color = (100,0,100)\n",
    "    revenue_base = BASE_REV_CONS_PAV\n",
    "    entities = []\n",
    "    def __init__(self,position_x=0, position_y=0, compte=0, revenu = revenue_base):\n",
    "        self.habitat = 1\n",
    "        self.compte = compte \n",
    "        self.position = Utils.Position(position_x, position_y)\n",
    "        self.revenu = BASE_REV_CONS_PAV\n",
    "        self.depenseAlim = BASE_DEP_ALIM_CON_PAV\n",
    "        self.coeffAlim = BASE_COEFF_ALIM_CON_PAV\n",
    "        self.positionWork = Utils.Position(50,50)\n",
    "        self.positionCom = self.position\n",
    "       \n",
    "        if(self.attachedMap != None):\n",
    "            ConsommateurPavillionnaire.entities.append(self)\n",
    "            self.attachedMap.tell(self)\n",
    "        else:\n",
    "            print(\"Please attach a map first\")\n",
    "\n",
    "    def give(self):\n",
    "        self.compte += self.revenu\n",
    "    @classmethod\n",
    "    def addNewToMap(cls, position = None, randomized= True):\n",
    "        if(position != None and cls.attachedMap.takenMat[position.x][position.y] == 0):\n",
    "                ConsommateurPavillionnaire(position.x, position.y)\n",
    "        elif randomized:\n",
    "                if(len(cls.attachedMap.free_list) != 0):\n",
    "                    chosen_pos = random.choice(cls.attachedMap.free_list)\n",
    "                    \n",
    "                    ConsommateurPavillionnaire(chosen_pos[0], chosen_pos[1])\n",
    "     \n",
    "class ConsommateurBanl(Consommateur):\n",
    "    color = (0,0,100)\n",
    "    revenue_base = BASE_REV_CONS\n",
    "    entities = []\n",
    "    def __init__(self,position_x=0, position_y=0, compte=0, revenu = revenue_base):\n",
    "        self.habitat = 1\n",
    "        self.compte = compte \n",
    "        self.position = Utils.Position(position_x, position_y)\n",
    "        self.revenu = BASE_REV_CONS\n",
    "        self.depenseAlim = BASE_DEP_ALIM_CON_BANL \n",
    "        self.coeffAlim = BASE_COEFF_ALIM_CON_BANL\n",
    "        self.positionCom = self.position\n",
    "        self.positionWork = Utils.Position(50,50)\n",
    "        if(self.attachedMap != None):\n",
    "            ConsommateurBanl.entities.append(self)\n",
    "            self.attachedMap.tell(self)\n",
    "        else:\n",
    "            print(\"Please attach a map first\")\n",
    "\n",
    "    def give(self):\n",
    "        self.compte += self.revenu\n",
    "    @classmethod\n",
    "    def addNewToMap(cls, position = None, randomized= True):\n",
    "        if(position != None and cls.attachedMap.takenMat[position.x][position.y] == 0):\n",
    "                ConsommateurBanl(position.x, position.y)\n",
    "        elif randomized:\n",
    "                if(len(cls.attachedMap.free_list) != 0):\n",
    "                    chosen_pos = random.choice(cls.attachedMap.free_list)\n",
    "                    \n",
    "                    ConsommateurBanl(chosen_pos[0], chosen_pos[1])\n",
    "class ConsommateurVille(Consommateur):\n",
    "    color = (0,100,100)\n",
    "    revenue_base = BASE_REV_CONS_VILLE\n",
    "    entities = []\n",
    "    def __init__(self,position_x=0, position_y=0, compte=0, revenu = revenue_base):\n",
    "        self.habitat = 1\n",
    "        self.compte = compte \n",
    "        self.position = Utils.Position(position_x, position_y)\n",
    "        self.revenu = BASE_REV_CONS_VILLE\n",
    "        self.depenseAlim = BASE_DEP_ALIM_CON_VILLE \n",
    "        self.coeffAlim = BASE_COEFF_ALIM_CON_VILLE\n",
    "        self.positionCom = self.position\n",
    "        self.positionWork = Utils.Position(50,50)\n",
    "        if(self.attachedMap != None):\n",
    "            ConsommateurVille.entities.append(self)\n",
    "            self.attachedMap.tell(self)\n",
    "        else:\n",
    "            print(\"Please attach a map first\")\n",
    "\n",
    "    def give(self):\n",
    "        self.compte += self.revenu\n",
    "    @classmethod\n",
    "    def addNewToMap(cls, position = None, randomized= True):\n",
    "        if(position != None and cls.attachedMap.takenMat[position.x][position.y] == 0):\n",
    "                ConsommateurVille(position.x, position.y)\n",
    "        elif randomized:\n",
    "                if(len(cls.attachedMap.free_list) != 0):\n",
    "                    chosen_pos = random.choice(cls.attachedMap.free_list)\n",
    "                    \n",
    "                    ConsommateurVille(chosen_pos[0], chosen_pos[1])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h1> Commerces </h1>\n",
    "Nous avons créer une classe simillaire pour les commerces. Ceux ci se distinguent en trois catégories qui nous servirons de base pour montrer nos résultats. \n",
    "\n",
    "<li>Commerce Alimentaire</li>\n",
    "<li>Commerce Divers</li>\n",
    "<li>Commerce Maison</li>\n",
    "\n",
    "Ces catégories visent à representer les différentes manières de consommer. Les commerces alimentaire représentent les consommations essentielles avec une minimum de dépense dans ces commerces pour chaque consommateurs. Les commerces maisons representent les commerces dans lesquels nous consommons de grande quantité, mais rarement. Enfin, les commerces divers sont ceux dans lesquels nous consommons lorsque nous avons consommé dans les précedents et qu'il nous reste d' argent.\n",
    "\n",
    "À chacun des commerces sont attachées des fonctions d'attractions, qui modélisent la probabilité pour un consommateur de consommer dans ce commerce plutôt qu'un autre de sa catégorie. \n",
    "Un compte des voisins de chaque commerce est également tenu afin de modéliser les regroupements. \n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Commerce:\n",
    "    entities = []\n",
    "    pos_set= [(si*i,sj*j) for i in range(int(PROPAGATION_RANGE/2)+1) for j in range(int(PROPAGATION_RANGE/2)+1) for si in (-1,1) for sj in (-1,1)]\n",
    "    while((0,0) in pos_set):\n",
    "        pos_set.remove((0,0))\n",
    "    attachedMap = None\n",
    "    def __init__(self,position_x, position_y,size,initCompte, open = True):\n",
    "        self.size = size\n",
    "        self.position = Utils.Position(position_x, position_y)\n",
    "        self.compte = initCompte\n",
    "        self.open = True\n",
    "        self.charge = 0   \n",
    "          \n",
    "    def calcnbVoisin(self):\n",
    "        count = 0\n",
    "        for commerce_t_entities in Commerce.entities:\n",
    "            for commerce in commerce_t_entities:\n",
    "                d = Utils.distance(commerce.position, self.position)\n",
    "                if(d< COM_PROXIMITY and d>0  and commerce.open):\n",
    "                    count+= 1\n",
    "        return count\n",
    "\n",
    "    def voisinSearch(self):\n",
    "        voisins = []\n",
    "        for commerce_t_entities in Commerce.entities:\n",
    "            for commerce in commerce_t_entities:\n",
    "                d = Utils.distance(commerce.position, self.position)\n",
    "                if(d< COM_PROXIMITY and d >0):\n",
    "                    if(commerce.open):\n",
    "                        voisins.append(commerce)\n",
    "        return voisins\n",
    "    def addVoisin(self):\n",
    "        self.nbVoisin +=1\n",
    "    def removeVoisin(self):\n",
    "        self.nbVoisin -=1\n",
    "\n",
    "    @classmethod \n",
    "    def attachMap(cls, map):\n",
    "        cls.attachedMap = map\n",
    "    def printSummary(self):\n",
    "        print(\"\\nSummary about : \"+ self.__repr__())\n",
    "        print(\"Compte : \"+str(self.compte))\n",
    "        print(\"nbVoisin : \"+str(self.nbVoisin))\n",
    "        print(\"Open:\"+str(self.open))\n",
    "        print(\"ConsecutiveNeg \" + str(self.consecutiveNeg))\n",
    "        print(\"Money / Charge {x}\".format(x=self.compte/self.charge))\n",
    "    def updateMapClose(self):\n",
    "        self.attachedMap.updateCase(self.position, [0,0,0])\n",
    "    def update(self):\n",
    "        self.compte -= self.charge\n",
    "        self.compte+= self.turnMoney\n",
    "        self.turnMoney = 0\n",
    "        self.updateCharge()\n",
    "        if(self.open):\n",
    "            if(self.compte <0):\n",
    "                self.consecutiveNeg +=1\n",
    "                if(self.consecutiveNeg >30):\n",
    "                    voisins = self.voisinSearch()\n",
    "                    for voisin in voisins:\n",
    "                        voisin.removeVoisin()\n",
    "                    self.open = False\n",
    "                    self.updateMapClose()\n",
    "                    self.entities.remove(self)\n",
    "                    self.attachedMap.remove(self)\n",
    "            else:\n",
    "\n",
    "                self.consecutiveNeg = 0      "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "On a la classe commerce Alimentaire"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "class CommerceAlim(Commerce):\n",
    "    entities = []\n",
    "    color = (255,0,0)\n",
    "    alpha = ALPHA_ALIM\n",
    "    beta = BETA_ALIM\n",
    "    gamma = GAMMA_ALIM\n",
    "    a = A_ALIM \n",
    "    b = B_ALIM \n",
    "    c = C_ALIM\n",
    "    def updateCharge(self):\n",
    "        self.charge = BASE_CHARGE_ALIM *(1+ self.gamma * self.nbVoisin)\n",
    "    def __init__(self,position_x = 0, position_y=0,size=0,initCompte=0, open = True):\n",
    "        self.size = size\n",
    "        self.position = Utils.Position(position_x, position_y)\n",
    "        self.compte = initCompte\n",
    "        self.open = True\n",
    "        self.turnMoney = 0\n",
    "        self.nbVoisin = self.calcnbVoisin()\n",
    "        self.consecutiveNeg = 0\n",
    "        self.charge = BASE_CHARGE_ALIM\n",
    "        if(self.attachedMap == None):\n",
    "            print(\"Please attach map first\")  \n",
    "        else:\n",
    "            for commerce in self.voisinSearch():\n",
    "                commerce.addVoisin()\n",
    "    \n",
    "            self.attachedMap.tell(self)\n",
    "            CommerceAlim.entities.append(self)\n",
    "        \n",
    "    def f_attrac(self, cons,index_tire):\n",
    "        if(self.turnMoney<self.charge * 3):\n",
    "            if(index_tire == 0):\n",
    "                d1= Utils.distance(cons.positionCom, self.position)\n",
    "            elif(index_tire == 1):\n",
    "                d1 = Utils.distance(cons.position, self.position)\n",
    "            else:\n",
    "                d1 = Utils.distance(cons.positionWork, self.position)\n",
    "\n",
    "        \n",
    "            if(d1 == 0):\n",
    "                return self(self.nbVoisin,1)\n",
    "            else:\n",
    "                return ( max(self.nbVoisin,1) ** CommerceAlim.alpha) /(d1**CommerceAlim.beta)\n",
    "        else:\n",
    "            return 0\n",
    "    def f_propagate(self,pos_set):\n",
    "        \n",
    "        dist = abs(pos_set[0]) + abs(pos_set[1])\n",
    "        \n",
    "        if dist == 0 :\n",
    "            return 0\n",
    "        return (self.compte / (dist **2), self.charge/(dist**2))\n",
    "    def propagateOnMap(self):\n",
    "        coeffs_ = [1]\n",
    "        \n",
    "        if(self.compte > 2*self.charge and self.open):\n",
    "           \n",
    "            for i in range(PROPAGATION_RANGE * PROPAGATION_RANGE):\n",
    "                    y = self.position.y + self.pos_set[i][1]\n",
    "                    x = self.position.x + self.pos_set[i][0]\n",
    "                    \n",
    "                    if( 0<x <self.attachedMap.size and 0<y<self.attachedMap.size and self.attachedMap.takenMat[x][y] == 0):\n",
    "                        res = self.f_propagate(self.pos_set[i])\n",
    "                        coeffs_.append(res[0])\n",
    "                        coeffs_[0]+=res[1]\n",
    "                    else:\n",
    "                        coeffs_.append(0)\n",
    "            if(len(coeffs_)>0):\n",
    "                index_tire = random.choices(range(len(coeffs_)), weights=coeffs_)[0]\n",
    "                if(index_tire >0):\n",
    "                   \n",
    "                    y = self.position.y + self.pos_set[index_tire-1][1]\n",
    "                    x = self.position.x + self.pos_set[index_tire-1][0]\n",
    "                    CommerceAlim(x,y)\n",
    "    def __repr__(self):\n",
    "        return \"ComAlim(\"+str(self.position.x)+\",\"+str(self.position.y)+\")\"\n",
    "    @classmethod\n",
    "    def addNewToMap(cls, position = None, randomized= True):\n",
    "        if(position != None and cls.attachedMap.takenMat[position.x][position.y] == 0):\n",
    "            CommerceAlim(position.x, position.y)\n",
    "        elif randomized:\n",
    "            if(len(cls.attachedMap.free_list) != 0):\n",
    "                chosen_pos = random.choice(cls.attachedMap.free_list)\n",
    "                CommerceAlim(chosen_pos[0], chosen_pos[1])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Une classe CommerceDiv"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "class CommerceDiv(Commerce):\n",
    "    entities = []\n",
    "    alpha = ALPHA_DIV\n",
    "    beta = BETA_DIV\n",
    "    color = (0,255,0)\n",
    "    gamma = GAMMA_DIV\n",
    "    a = A_DIV \n",
    "    b = B_DIV \n",
    "    c = C_DIV\n",
    "    def updateCharge(self):\n",
    "        self.charge = BASE_CHARGE_DIV *(1+ self.gamma * self.nbVoisin)\n",
    "    def __init__(self,position_x, position_y,size=0,initCompte=0,open = True):\n",
    "        self.size = size\n",
    "        self.position = Utils.Position(position_x, position_y)\n",
    "        self.compte = initCompte\n",
    "        self.open = open \n",
    "        self.turnMoney = 0\n",
    "        self.nbVoisin = self.calcnbVoisin()\n",
    "        self.consecutiveNeg = 0\n",
    "        self.charge = BASE_CHARGE_DIV\n",
    "        if(self.attachedMap == None):\n",
    "            print(\"Please attach map first\")  \n",
    "        else:\n",
    "            for commerce in self.voisinSearch():\n",
    "                commerce.addVoisin()\n",
    "            self.attachedMap.tell(self)\n",
    "            CommerceDiv.entities.append(self)\n",
    "            \n",
    "    def f_attrac(self, cons,index_tire):\n",
    "        if(self.turnMoney < 3*self.charge):\n",
    "            if(index_tire == 0):\n",
    "                d1= Utils.distance(cons.positionCom, self.position)\n",
    "            elif(index_tire == 1):\n",
    "                d1 = Utils.distance(cons.position, self.position)\n",
    "            else:\n",
    "                d1 = Utils.distance(cons.positionWork, self.position)\n",
    "\n",
    "            \n",
    "            if(d1 == 0):\n",
    "                return max(self.nbVoisin,1)\n",
    "            else:\n",
    "                return ( max(self.nbVoisin,1) ** CommerceDiv.alpha) /(d1**CommerceDiv.beta)\n",
    "        else:\n",
    "            return 0\n",
    "    def f_propagate(self,pos_set):\n",
    "        \n",
    "        dist = abs(pos_set[0]) + abs(pos_set[1])\n",
    "        \n",
    "        if dist == 0 :\n",
    "            return 0\n",
    "        return (self.compte / (dist **2), self.charge/(dist**2))\n",
    "    def propagateOnMap(self):\n",
    "        coeffs_ = [1]\n",
    "        \n",
    "        if(self.compte > 2*self.charge and self.open):\n",
    "           \n",
    "            for i in range(PROPAGATION_RANGE * PROPAGATION_RANGE):\n",
    "                    y = self.position.y + self.pos_set[i][1]\n",
    "                    x = self.position.x + self.pos_set[i][0]\n",
    "                    \n",
    "                    if( 0<x <self.attachedMap.size and 0<y<self.attachedMap.size and self.attachedMap.takenMat[x][y] == 0):\n",
    "                        res = self.f_propagate(self.pos_set[i])\n",
    "                        coeffs_.append(res[0])\n",
    "                        coeffs_[0]+=res[1]\n",
    "                    else:\n",
    "                        coeffs_.append(0)\n",
    "            if(len(coeffs_)>0):\n",
    "                index_tire = random.choices(range(len(coeffs_)), weights=coeffs_)[0]\n",
    "                if(index_tire >0):\n",
    "                    \n",
    "                    y = self.position.y + self.pos_set[index_tire-1][1]\n",
    "                    x = self.position.x + self.pos_set[index_tire-1][0]\n",
    "                    CommerceDiv(x,y)\n",
    "    \n",
    "    @classmethod\n",
    "    def addNewToMap(cls, position = None, randomized= True):\n",
    "        if(position != None and cls.attachedMap.takenMat[position.x][position.y] == 0):\n",
    "            CommerceDiv(position.x, position.y)\n",
    "        elif randomized:\n",
    "            if(len(cls.attachedMap.free_list) != 0):\n",
    "                chosen_pos = random.choice(cls.attachedMap.free_list)\n",
    "                CommerceDiv(chosen_pos[0], chosen_pos[1])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Une classe CommerceMaison"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "class CommerceMaison(Commerce):\n",
    "    entities = []\n",
    "    alpha = ALPHA_MAIS\n",
    "    beta = BETA_MAIS\n",
    "    color = (255,155,255)\n",
    "    gamma = GAMMA_MAIS\n",
    "    a = A_MAIS\n",
    "    b = B_MAIS\n",
    "    c = C_MAIS\n",
    "    def updateCharge(self):\n",
    "        self.charge = BASE_CHARGE_MAIS *(1+ self.gamma * self.nbVoisin)\n",
    "    def __init__(self,position_x, position_y,size=0,initCompte=0,open = True):\n",
    "        self.size = size\n",
    "        self.position = Utils.Position(position_x, position_y)\n",
    "        self.compte = initCompte\n",
    "        self.open = open \n",
    "        self.turnMoney = 0\n",
    "        self.nbVoisin = self.calcnbVoisin()\n",
    "        self.consecutiveNeg = 0\n",
    "        self.charge = BASE_CHARGE_MAIS\n",
    "        if(self.attachedMap == None):\n",
    "            print(\"Please attach map first\")  \n",
    "        else:\n",
    "            for commerce in self.voisinSearch():\n",
    "                commerce.addVoisin()\n",
    "            self.attachedMap.tell(self)\n",
    "            CommerceMaison.entities.append(self)\n",
    "            \n",
    "    def f_attrac(self, cons,index_tire):\n",
    "        if(self.turnMoney < 15*self.charge):\n",
    "            if(index_tire == 0):\n",
    "                d1= Utils.distance(cons.positionCom, self.position)\n",
    "            elif(index_tire == 1):\n",
    "                d1 = Utils.distance(cons.position, self.position)\n",
    "            else:\n",
    "                d1 = Utils.distance(cons.positionWork, self.position)\n",
    "\n",
    "            \n",
    "            if(d1 == 0):\n",
    "                return max(self.nbVoisin,1)\n",
    "            else:\n",
    "                return ( max(self.nbVoisin,1) ** CommerceMaison.alpha) /(d1**CommerceMaison.beta)\n",
    "        else:\n",
    "            return 0\n",
    "    def f_propagate(self,pos_set):\n",
    "        \n",
    "        dist = abs(pos_set[0]) + abs(pos_set[1])\n",
    "        \n",
    "        if dist == 0 :\n",
    "            return 0\n",
    "        return (self.compte / (dist **2), self.charge/(dist**2))\n",
    "    def propagateOnMap(self):\n",
    "        coeffs_ = [1]\n",
    "        if(self.compte > 2*self.charge and self.open):\n",
    "           \n",
    "            for i in range(PROPAGATION_RANGE * PROPAGATION_RANGE):\n",
    "                    y = self.position.y + self.pos_set[i][1]\n",
    "                    x = self.position.x + self.pos_set[i][0]\n",
    "                    \n",
    "                    if( 0<x <self.attachedMap.size and 0<y<self.attachedMap.size and self.attachedMap.takenMat[x][y] == 0):\n",
    "                        res = self.f_propagate(self.pos_set[i])\n",
    "                        coeffs_.append(res[0])\n",
    "                        coeffs_[0]+=res[1]\n",
    "                    else:\n",
    "                        coeffs_.append(0)\n",
    "            if(len(coeffs_)>0):\n",
    "                index_tire = random.choices(range(len(coeffs_)), weights=coeffs_)[0]\n",
    "                if(index_tire >0):\n",
    "                    \n",
    "                    y = self.position.y + self.pos_set[index_tire-1][1]\n",
    "                    x = self.position.x + self.pos_set[index_tire-1][0]\n",
    "                    CommerceMaison(x,y)\n",
    "    \n",
    "    @classmethod\n",
    "    def addNewToMap(cls, position = None, randomized= True):\n",
    "        if(position != None and cls.attachedMap.takenMat[position.x][position.y] == 0):\n",
    "            CommerceMaison(position.x, position.y)\n",
    "        elif randomized:\n",
    "            if(len(cls.attachedMap.free_list) != 0):\n",
    "                chosen_pos = random.choice(cls.attachedMap.free_list)\n",
    "                CommerceMaison(chosen_pos[0], chosen_pos[1])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "consClass = [ConsommateurBanl, ConsommateurPavillionnaire, ConsommateurVille]\n",
    "comClass = [CommerceAlim, CommerceDiv, CommerceMaison]\n",
    "Commerce.entities = [CommerceAlim.entities, CommerceDiv.entities,CommerceMaison.entities]\n",
    "Consommateur.entities = [ConsommateurBanl.entities, ConsommateurPavillionnaire.entities, ConsommateurVille.entities]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "De nombreux paramètres sont accessibles et influencent le résultat de la simulation, à chacun de ces paramètres nous pouvons associer un comportement ou une préference économique des agents consommateurs. \n",
    "\n",
    "Les facteurs A,B,C et leurs rapports, permettent d'exprimer l'importance des distances (Commerce, Maison), (Commerce, Travail), (Commerce, Dernier Commerce visité) dans l'évaluation par le consommateur de son choix de consommer ou non dans un commerce. \n",
    "\n",
    "En cas d'égalité, un consommateur consommera une fois sur trois en fonction de son lieu de travail, etc..\n",
    "\n",
    "Les coefficients alpha et beta répresentent l'importance pour les consommateurs des facteurs distance et nombre de voisins lors de son choix de consommation.\n",
    "\n",
    "Si Alpha est grand, les consommateurs préferont consommer à un endroit où il y a plusieurs autres commerces.\n",
    "\n",
    "Le coefficient Gamma, représente le coùt pour un commerce de ses voisins, cela répresente l'augmentation des charges en raison de l'attractivité d'un lieu. \n",
    "\n",
    "Les autres coefficients, concernent les revenus des différents types de population"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<__main__.Map object at 0x1106c0230>\n",
      "24604000\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2024-04-27 02:39:09.594 Python[33027:230432] WARNING: Secure coding is not enabled for restorable state! Enable secure coding by implementing NSApplicationDelegate.applicationSupportsSecureRestorableState: and returning YES.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Tried to put outside of map or in used place\n",
      "Tried to put outside of map or in used place\n"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[9], line 93\u001b[0m\n\u001b[1;32m     91\u001b[0m VERBOSE \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m0\u001b[39m\n\u001b[1;32m     92\u001b[0m NUMBER_OF_ITERATIONS \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m600\u001b[39m\n\u001b[0;32m---> 93\u001b[0m \u001b[38;5;28;43mmap\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mprintMap\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m     95\u001b[0m nb_voisins \u001b[38;5;241m=\u001b[39m []\n\u001b[1;32m     96\u001b[0m nb_voisins_differents \u001b[38;5;241m=\u001b[39m []\n",
      "Cell \u001b[0;32mIn[2], line 54\u001b[0m, in \u001b[0;36mMap.printMap\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m     51\u001b[0m         \u001b[38;5;28;01mif\u001b[39;00m event\u001b[38;5;241m.\u001b[39mkey \u001b[38;5;241m==\u001b[39m pygame\u001b[38;5;241m.\u001b[39mK_p \u001b[38;5;129;01mand\u001b[39;00m pause:\n\u001b[1;32m     52\u001b[0m             \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mprintFullSummary()\n\u001b[0;32m---> 54\u001b[0m \u001b[43mscreen\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mfill\u001b[49m\u001b[43m(\u001b[49m\u001b[43mwhite\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m     55\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m(\u001b[38;5;129;01mnot\u001b[39;00m pause):\n\u001b[1;32m     57\u001b[0m     \u001b[38;5;28;01mfor\u001b[39;00m y \u001b[38;5;129;01min\u001b[39;00m \u001b[38;5;28mrange\u001b[39m(grid_height):\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    },
    {
     "ename": "",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31mThe Kernel crashed while executing code in the the current cell or a previous cell. Please review the code in the cell(s) to identify a possible cause of the failure. Click <a href='https://aka.ms/vscodeJupyterKernelCrash'>here</a> for more info. View Jupyter <a href='command:jupyter.viewOutput'>log</a> for further details."
     ]
    }
   ],
   "source": [
    "A_ALIM = 1 #Impact des commerces visités recemment\n",
    "B_ALIM = 1 #Impact de la position maison\n",
    "C_ALIM = 0 #Impact de la position du travail\n",
    "\n",
    "A_DIV = 1\n",
    "B_DIV = 1\n",
    "C_DIV = 1\n",
    "\n",
    "A_MAIS = 1\n",
    "B_MAIS = 1\n",
    "C_MAIS = 1\n",
    "\n",
    "ALPHA_ALIM = 5 #Impact du nombre de voisin\n",
    "BETA_ALIM = 3 #Impact de la distance ci dessus\n",
    "ALPHA_DIV = 2 \n",
    "BETA_DIV = 10\n",
    "GAMMA_DIV = 0.00 #Cout des voisins sur les commerces \n",
    "GAMMA_ALIM = 0.00\n",
    "\n",
    "ALPHA_MAIS = 5 #Impact du nombre de voisin\n",
    "BETA_MAIS = 3 \n",
    "GAMMA_MAIS = 0.00\n",
    "\n",
    "#800 -> 800 00\n",
    "\n",
    "#1 bloc \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "BASE_REV_CONS_PAV = 1000\n",
    "\n",
    "BASE_REV_CONS = 30 *BASE_REV_CONS_PAV #Revenu miniaml\n",
    "BASE_REV_CONS_VILLE = (BASE_REV_CONS_PAV+BASE_REV_CONS_PAV)/2\n",
    "BASE_CONS_ALIM = 300 #Dépense minimal alimentaire\n",
    "\n",
    "BASE_DEP_ALIM_CON_BANL = 100 * BASE_CONS_ALIM \n",
    "BASE_DEP_ALIM_CON_VILLE = 3*BASE_CONS_ALIM \n",
    "BASE_DEP_ALIM_CON_PAV = BASE_CONS_ALIM \n",
    "\n",
    "BASE_COEFF_ALIM_CON_VILLE = 0.2\n",
    "BASE_COEFF_ALIM_CON_BANL = 0.1\n",
    "BASE_COEFF_ALIM_CON_PAV = 0.4\n",
    "\n",
    "BASE_CHARGE_ALIM = 100000\n",
    "BASE_CHARGE_DIV = 100000\n",
    "BASE_CHARGE_MAIS = 10000\n",
    "\n",
    "\n",
    "COM_PROXIMITY = 7\n",
    "BASE_REV_CONS_VILLE = 2*BASE_REV_CONS\n",
    "NUMBER_OF_ITERATIONS = 600\n",
    "VERBOSE = 1\n",
    "PROPAGATION_RANGE = 4#must be even\n",
    "if True:\n",
    "    x_axis = [i for i in range(100)]\n",
    "    map = Map(100)\n",
    "    print(map)\n",
    "    Commerce.attachMap(map)\n",
    "    Consommateur.attachMap(map)\n",
    "\n",
    "    for i in range(100):\n",
    "        for j in range(100):\n",
    "            if((i-50)**2+(j-50)**2 < 250):\n",
    "                if(j%2==0 and i%2==0):\n",
    "                    ConsommateurVille.addNewToMap(Utils.Position(i,j))\n",
    "                    \n",
    "            elif((i-50)**2+(j-50)**2 > 450 and (i-50)**2 + (j-50)**2 < 1000):\n",
    "                if(j%2==0 and i%2==0):\n",
    "                    ConsommateurBanl.addNewToMap(Utils.Position(i,j))\n",
    "                    pass\n",
    "            elif((i-50)**2+(j-50)**2 > 1000 and (i-50)**2 + (j-50)**2 < 2000):\n",
    "                if(j%4 == 0 and i%4==0):\n",
    "                    ConsommateurPavillionnaire.addNewToMap(Utils.Position(i,j))\n",
    "                    pass\n",
    "\n",
    "\n",
    "\n",
    "    nbConsVille = len(ConsommateurVille.entities)\n",
    "    nbConsBanl = len(ConsommateurBanl.entities)\n",
    "    nbConsPav = len(ConsommateurPavillionnaire.entities)\n",
    "    TOT_REVENU = nbConsVille*BASE_REV_CONS_VILLE + nbConsBanl * BASE_REV_CONS + nbConsPav * BASE_REV_CONS_PAV\n",
    "\n",
    "    REV_ALIM = (nbConsVille*BASE_DEP_ALIM_CON_VILLE+nbConsPav*BASE_DEP_ALIM_CON_PAV+nbConsBanl*BASE_DEP_ALIM_CON_BANL)*BASE_CONS_ALIM + (TOT_REVENU* (nbConsVille*BASE_COEFF_ALIM_CON_VILLE+nbConsPav*BASE_COEFF_ALIM_CON_PAV+nbConsBanl*BASE_COEFF_ALIM_CON_BANL))/(nbConsPav+nbConsBanl+nbConsVille)\n",
    "    print(TOT_REVENU)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "    VERBOSE = 0\n",
    "    NUMBER_OF_ITERATIONS = 600\n",
    "    map.printMap()\n",
    "\n",
    "    nb_voisins = []\n",
    "    nb_voisins_differents = []\n",
    "    dist_center = []\n",
    "    for com_t_entities in Commerce.entities:\n",
    "        for com in com_t_entities:\n",
    "            dist_center.append(Utils.distance(com.position, Utils.Position(50,50)))\n",
    "            n1 = 0\n",
    "            n2 = 0\n",
    "            for other_com_t_entities in Commerce.entities:\n",
    "                for other_com in other_com_t_entities:\n",
    "                    d = Utils.distance(com.position, other_com.position)\n",
    "                    if( d < COM_PROXIMITY):\n",
    "                        n1 += 1 \n",
    "                        if com_t_entities != other_com_t_entities:\n",
    "                            n2+=1\n",
    "            nb_voisins.append(n1)\n",
    "            nb_voisins_differents.append(n2)\n",
    "    print(\"Nombre de voisins moyen :{m1}\\n Distance moyenne au centre : {m2}\\n Nombre de voisins d'autre type moyen: {m3}\")\n",
    "\n",
    "    list_res.append((nb_voisins.copy(), nb_voisins_differents.copy(), dist_center.copy()))\n",
    "  "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "RLenv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
